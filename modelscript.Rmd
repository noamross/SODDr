
<!-- Automatically generated by RStudio [12861c30b10411e1afa60800200c9a66] -->
### modelscript.R
noamross --- *Nov 9, 2012, 9:43 AM*`r opts_chunk$set(tidy=FALSE, comment=NA, fig.path='figure-compile-notebook-12861c30b/')`
```{r}
## Performance flags

parallel.flag <- FALSE
progress.flag <- !parallel.flag && interactive()
require(gdata)
require(plyr)
require(reshape2)
require(ggplot2)

# 1.  Set up species/classes
#' Import a CSV of parameters, process, and return objects to parent environment fadskjhf asjdhgf adgjhadsk
#' @import gdata
#' 
#'

  treeparms.df <- read.csv("paper_tree_parms.csv", stringsAsFactors=FALSE)
  classes <- 1:nrow(treeparms.df)
    names(classes) <- paste(treeparms.df$species, ",", treeparms.df$ageclass,sep="")
  treeparms.df <- cbind(class=classes, treeparms.df)
  n.species <- length(unique(treeparms.df$species))
  n.classes <- nrow(treeparms.df)
  ageclasses <-as.vector(table(treeparms.df$species))
    names(ageclasses) <- 1:n.species
  waifw <- as.matrix(treeparms.df[,matchcols(treeparms.df, with="waifw[0-9]+"),])
    dimnames(waifw) <- list(names(classes),names(classes))
  recruit.vec <- as.vector(rbind(treeparms.df$S.recruit, treeparms.df$I.recruit))
  mort.vec <- as.vector(rbind(treeparms.df$S.mortality, treeparms.df$I.mortality))
  trans.vec <- as.vector(rbind(treeparms.df$S.transition, treeparms.df$I.transition))
  resprout.vec <- as.vector(rbind(treeparms.df$S.resprout, treeparms.df$I.resprout))
  recover <- treeparms.df$recover
  space <- treeparms.df$space

#

#'This function returns the first argument for distances < 0.5, the second for distances [0.5,1.5], zero for others
adjacent.dispersal <- function(distance, local, adjacent) {
  ifelse(distance < 0.5, local,
         ifelse(distance < 1.5, adjacent,0)
  )
}

#' Produced multiplier for new recruits given population and space vectors
DensityDependence <- function(pop, space) { 
  E <- 1 - sum(pop*space)
  return(E)
}
# 2. Set up locations.  In this case, a lattice


#'Generate a lattice of equally spaced locations and coordinates
MakeLattice <- function(nx, ny, dist=1) {
  locations <- cbind(location = 1:(nx*ny), 
                     x = rep(seq(from=0, by=dist, length.out=nx), each=ny),
                     y = rep(seq(from=0, by=dist, length.out=ny), times=nx)
                )
  return(locations)
}

locations <- MakeLattice(20,20,1)
n.locations <- nrow(locations)
  
#'Generate a distance matrix from locations.

distance.matrix <- as.matrix(dist(locations[,c("x","y")]))
  
# Generate dispersal matrices for each class
spread.matrices <- daply(treeparms.df,"class", function(x) {
  do.call(x$kernel.fn, 
          unname(c(list(distance.matrix), 
                   as.list(na.omit(x[matchcols(x, "kernel.par[0-9]+")]))
          ))
  )
})
  

# Set simulation parameters

time.steps <- 1:500

# Create transition matrix
# TODO: Make this into a function
  
tran.mat <- matrix(0, nrow=n.classes*2, ncol=n.classes*2)
diags <- row(tran.mat) - col(tran.mat)
fec.mat <- tran.mat
diag(tran.mat) <- 1 - trans.vec - mort.vec
  
tran.mat[diags==1] <- diag(tran.mat)[-(nrow(tran.mat))] * rep(c(1,0),n.classes)[-(nrow(tran.mat))]
tran.mat[diags==-1] <- diag(tran.mat)[-1] * rep(c(1,0),n.classes)[-(nrow(tran.mat))]

tran.mat[diags==2] <- trans.vec[1:(n.classes*2 - 2)]
tran.mat[diags==3] <- trans.vec[1:(n.classes*2 -3)] * rep(c(1,0),n.classes)[1:(n.classes*2 - 3)]
tran.mat[diags==1] <- tran.mat[diags==1] + trans.vec[1:(n.classes*2-1)] * rep(c(0,1), n.classes)[1:(n.classes*2 - 1)]
  
# Step update is (trans.mat * force.mat + fec.mat) * population
  
# Initiatte
  
pop <- array(NA, dim=c(length(time.steps), n.locations, 2*n.classes), 
             dimnames=list(Time=time.steps,
                           Location=1:n.locations, 
                           Class=paste(rep(names(classes),each=2),rep(c("S","I"),n.classes),sep=",")))
pop.init <- matrix(data=c(0.33/4,0,0.33/4,0,0.33/4,0,0.33/4,0, 0.33,0,0.34,0), nrow=n.locations, ncol=(2*n.classes), byrow=TRUE)
pop[1,,] <- pop.init

spore.burden <- matrix(NA, nrow=n.classes, ncol=n.locations)
Rprof("out.prof")

for(time in time.steps[-(length(time.steps))]) {
  
# First act in simulation step.  Given population at each location, calculate spore burden at each location
  for(class in classes) {
      spore.burden[class,] <- pop[time,,class*2] %*% spread.matrices[class,,]
  }
  
  force.infection <- waifw %*% spore.burden
  real.recovery <- (1-force.infection) * recover

  for(location in 1:n.locations) {
    force <- force.infection[,location]
    real.rec <- real.recovery[,location]
    force.matrix <- kronecker(rep(1,n.classes),
                              rbind(as.vector(rbind(1-force,real.rec)),
                              as.vector(rbind(force, 1-real.rec))))
    E <- DensityDependence(pop[time,location,], space)
    for(i in 1:n.species) {
      classindex <- 1:(2*ageclasses[i]) + (sum(ageclasses[0:(i-1)])*2)
      fec.mat[classindex[1],classindex] <- (E*recruit.vec + resprout.vec*mort.vec)[classindex]  #Fecundities + Death X Resprout probabilties
    }
    trans.mat <- tran.mat*force.matrix + fec.mat
    pop[time + 1,location,] <- trans.mat %*% pop[time,location,]
  }
}
Rprof(NULL)

# Plot

# Convert to a data frame

pop.df <- melt(pop, value.name="Population")
pop.df$Class <- factor(pop.df$Class, levels(pop.df$Class)[as.vector(rbind(seq(2,n.classes*2,by=2), seq(1,n.classes*2-1, by=2)))])
pop.df <- arrange(pop.df, Time,Location,Class)
pop.df$Species <- rep(treeparms.df$species, each=2)
pop.df$AgeClass <- rep(treeparms.df$ageclass, each=2)
pop.df$Disease <- factor(c("S","I"), c("S","I"))
pop.df$Class <- NULL
densfun <- function(x) {sum(x)/n.locations}
dynamic.plot <- ggplot(pop.df, aes(x=Time,y=Population, fill=Disease)) + stat_summary(fun.y="densfun", geom="area", position="stack",alpha=0.6) + facet_grid(~Species)
dynamic.plot
#pop$infected <- rep(c("S","I"), nrow(pop)/2)
summaryRprof("out.prof")
```
