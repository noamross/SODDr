#' Create a hex grid around a set of site locations
#' 
#' Creates a hex lattice of points overlain on a series of plot locations,
#' matching each real plot location with its nearest neighbor grid point. The
#' origin is adjusted to minimize the sum squared error difference between
#' actual and grid plot locations.
#' 
#' @param locations a data frame or matrix of locations.  The last two column 
#'   must be the X and Y locations of the sites
#' @param plot.area the area (in sq. meters) of the circular plot locations.
#'   Used to calculate the grid size so hex cells are of the same area
#' @param buffer the amount of buffer space around the edgemost points to put in the
#'   grid.  As a fraction of the total distance between the extreme points.
#' @return An object of the class "lattice" which is a matrix generated by 
#'   \code{\link{MakeHexLattice}} of site locations.  It has the additional
#'   attribute \code{nn} which is the \code{locations} parameter with an
#'   additional column, \code{lattice.nn} denoting the nearest-neighbor points
#'   on the lattice to each of the plot locations.
#' @import matrixStats
#' @import fields
#' @export
FitLattice <- function(locations, plot.area=500, buffer=0.1) {
  
  #Make sure locations are a nX2 matrix
  locs <- as.matrix(locations[,(ncol(locations)-1):ncol(locations)])
  
  #Calculate the inter-hex distance from the radial plot area
  scale = sqrt(plot.area*2/(3*sqrt(3)))

  bb <- t(colRanges(as.matrix(locs)))
  center.point <- colMeans(bb)
  bb <- rbind(bb[1,] - (center.point - bb[1,])*2*buffer,
              bb[2,] + (bb[2,] - center.point)*2*buffer)

  lattice <- MakeHexLattice(nx = ceiling((bb[2,1]-bb[1,1])/scale),
                            ny = ceiling(2*(bb[2,2]-bb[1,2])/(scale*sqrt(3))),
                            dist = scale, origin=bb[1,])[,2:3]

  LatticeError <- function(x.off=0,y.off=0) {
    lattice <- cbind(lattice[,1] + x.off, lattice[,2] + y.off)
    d.mat <- rdist(rbind(locs, lattice))[1:nrow(locs),(nrow(locs)+1):(nrow(locs)+nrow(lattice))]
    error=sum(rowMins(d.mat)^2)
    return(error)
  }

  opt <- optim(par=c(x.off=0,y.off=0), fn=LatticeError)
  lattice2 <- MakeHexLattice(nx = ceiling((bb[2,1]-bb[1,1])/scale),
                            ny = ceiling(2*(bb[2,2]-bb[1,2])/(scale*sqrt(3))),
                            dist = scale, origin=bb[1,] + opt$par)


d.mat <- rdist(rbind(locs, lattice2[,2:3]))[1:nrow(locs),(nrow(locs)+1):(nrow(locs)+nrow(lattice2))]
locations <- cbind(locations, lattice.nn=aaply(d.mat, 1, which.min))
attr(lattice2, "nn") <- locations
return(lattice2)
}



