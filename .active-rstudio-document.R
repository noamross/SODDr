require(bitops, quietly=TRUE) require(ROAuth, quietly=TRUE) require(twitteR, quietly=TRUE) require(utils, quietly=TRUE)  twit <- function() {   registerTwitterOAuth(readRDS("~/twitcred.rds"))   #  a <- dmSend(paste("R twitter client activated",Sys.time()), "noamross")   invisible() }  twit()  dme <- function(message) {   a <- dmSend(message,"noamross")   invisible() }  lsp <-function(package, all.names = FALSE, pattern) {   package <- deparse(substitute(package))   ls(     pos = paste("package", package, sep = ":"),     all.names = all.names,     pattern = pattern   ) }  .ls.objects <- function (pos = 1, pattern, order.by,                          decreasing=FALSE, head=FALSE, n=5) {   napply <- function(names, fn) sapply(names, function(x)     fn(get(x, pos = pos)))   names <- ls(pos = pos, pattern = pattern)   obj.class <- napply(names, function(x) as.character(class(x))[1])   obj.mode <- napply(names, mode)   obj.type <- ifelse(is.na(obj.class), obj.mode, obj.class)   obj.prettysize <- napply(names, function(x) {     capture.output(print(object.size(x), units = "auto")) })   obj.size <- napply(names, object.size)   obj.dim <- t(napply(names, function(x)     as.numeric(dim(x))[1:2]))   vec <- is.na(obj.dim)[, 1] & (obj.type != "function")   obj.dim[vec, 1] <- napply(names, length)[vec]   out <- data.frame(obj.type, obj.size, obj.prettysize, obj.dim)   names(out) <- c("Type", "Size", "PrettySize", "Rows", "Columns")   if (!missing(order.by))     out <- out[order(out[[order.by]], decreasing=decreasing), ]   if (head)     out <- head(out, n)   out }  # shorthand lso <- function(..., n=20) {   .ls.objects(..., order.by="Size", decreasing=TRUE, head=TRUE, n=n) }  is.compile <- function(func) {   # this function lets us know if a function has been byte-coded or not   if(class(func) != "function") stop("You need to enter a function")   last_2_lines <- tail(capture.output(func),2)   any(grepl("bytecode:", last_2_lines)) # returns TRUE if it finds the text "bytecode:" in any of the last two lines of the function's print }   #TODO: Change to sort/truncate results with similar stacks (parent functions), print depending on plot window proftable <- function(file) {   require(plyr)   sample.interval <- as.numeric(strsplit(readLines(file, 1), "=")[[1L]][2L])/1e+06   profdata <- as.matrix(read.table(file, header=FALSE, sep=" ", colClasses="character", skip=1, fill=TRUE, na.strings=""))   total.time <- nrow(profdata)*sample.interval   stacktable <- data.frame(table(aaply(profdata, 1, function(x) paste(rev(na.omit(x)), collapse=" > "))))   names(stacktable) <- c("Stack","PctTime")   stacktable$PctTime <- 100*stacktable$PctTime/nrow(profdata)   stacktable <- stacktable[order(stacktable$PctTime, decreasing=TRUE), c("PctTime", "Stack")]   rownames(stacktable) <- NULL   attr(stacktable, "total.time") <- total.time   print(stacktable, row.names=FALSE, right=FALSE, digits=3)   cat(paste("\nTotal Time:", total.time, "seconds"))   invisible(stacktable) }  TestFun <- function(fun, nrep=100000L, cmptest=NULL, prof=TRUE) {d   require(microbenchmark)   if(is.null(cmptest)) cmptest <- !is.compile(fun)    if(prof) Rprof("tmp1.out")   time1 <- microbenchmark(fun, times=nrep)   if(prof)  Rprof(NULL)   if(cmptest) {     require(compiler, quietly=TRUE)     cfun <- cmpfun(fun)     time2 <- microbenchmark(cfun, times=nrep)     cmpratio <- mean(time2$time)/mean(time1$time)   }   print(summaryRprof("tmp1.out"))   if(prof) file.remove("tmp1.out")   print(time1)   print(time2)   if(cmptest) cat(paste("\nCompiling improves speed by ", round((100*(1-cmpratio)),2),"%\n",sep="")) }  tt <- traceback()  #MyPkgs <- readRDS("~/Rshare/mypkgs.rds") #CurrInst <- installed.packages()[,"Package"] #ToInst <- MyPkgs[which(!(CurrInst %in% MyPkgs]  #.Last <- function() { #  saveRDS(installed.packages()[,"Package"],  "~/Rshare/mypkgs.rds") #}